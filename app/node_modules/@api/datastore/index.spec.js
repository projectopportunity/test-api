/* eslint-env mocha */
const { expect } = require('chai')
const chai = require('chai')
const { promises } = require('fs')
chai.use(require('chai-as-promised'))

const T = require('./index.js')

describe('the datastore module', () => {
    it('should export a function', () => {
        const expected = 'function'
        const actual = typeof T
        expect(actual).to.equal(expected)
    })

    describe('the instance returned by the function', () => {
        it('should always refer to the same instance', () => {
            const expected = T()
            const actual = T()
            expect(actual).to.equal(expected)
        })

        it('should have a property called "createUser"', () => {
            const instance = T()
            expect(instance).to.have.property('createUser')
        })

        it('should have a property called "init"', () => {
            const instance = T()
            expect(instance).to.have.property('init')
        })

        it('should have a property called "reset"', () => {
            const instance = T()
            expect(instance).to.have.property('reset')
        })


        describe('the "init" property', () => {
            let instance
            const ERR_INVALID_INPUT = 'the init method requires a connection string parameter that is in the form of a URI'
            
            before(() => {
                instance = T()
            })
            
            it('should be a function', () => {
                const expected = 'function'
                const actual = typeof instance.init
                expect(actual).to.equal(expected)
            })

            describe('the returned value', () => {
                it('should be a promise', () => {
                    const result = instance.init()
                    return expect(result).to.be.rejected
                })
            })

            it('should throw an error if param is missing', () => {
                const result = instance.init()
                return expect(result).to.be.rejectedWith(ERR_INVALID_INPUT)
            })

            it('should throw an error for invalid parameter values', () => {
                const badValues = ['', 5, null, 'not a uri']
                return Promise.all(
                    badValues.map((value) => {
                        return expect(instance.init(value)).to.be.rejectedWith(ERR_INVALID_INPUT)
                    })    
                )
            })

            context('when provided a valid connection string', () => {
                it('should work', () => {
                    const result = instance.init('sqlite::memory:')
                    return expect(result).to.be.fulfilled
                })
            })
        })

        describe('the "createUser" property', () => {
            let instance
            
            before(() => {
                instance = T()
            })
            
            it('should be a function', () => {
                const expected = 'function'
                const actual = typeof instance.createUser
                expect(actual).to.equal(expected)
            })

            describe('the returned value', () => {

                context('when the init method has not been called', () => {
                    it('should be rejected', () => {
                        const result = instance.createUser()
                        return expect(result).to.be.rejectedWith('Please call init first')
                    })
                })
                
                it.skip('should be resolve to a number', () => {
                    const result = instance.createUser({
                        username: 'test@email.com',
                        password: 'test',
                        name:{
                            first: 'firstName',
                            last: 'lastName'
                        }
                    })
                    return expect(result).to.eventually.be.a('number')
                })
            })
        })

        describe('the "reset" property', () => {
            let instance
                        
            before(() => {
                instance = T()
            })
            
            it('should be a function', () => {
                const expected = 'function'
                const actual = typeof instance.reset
                expect(actual).to.equal(expected)
            })

            describe('the returned value', () => {
                it('should be a promise', () => {
                    const result = instance.reset()
                    return expect(result).to.be.fulfilled
                })
                
            })
        })            
    })
})