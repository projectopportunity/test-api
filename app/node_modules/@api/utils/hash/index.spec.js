/* eslint-env mocha */

const T = require('./index.js')

/**
 * The maximum amount of time that the hashing should take in milliseconds
 * @type {Number}
 */
const MAX_TIME_LIMIT = 500

describe.only('the "hash" module', () => {
  it('should export an object', () => {
    const expected = 'object'
    const actual = typeof T

    expect(actual).to.equal(expected)
  })

  describe('the exported object', () => {

    it('should have a property called "createHash"', () => {
      const instance = T
      expect(instance).to.have.property('createHash')
    })

    it('should have a property called "compareHash"', () => {
      const instance = T
      expect(instance).to.have.property('compareHash')
    })

    describe('the "createHash" property', () => {
      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof T.createHash
    
        expect(actual).to.equal(expected)
      })

      it('should throw an error for invalid parameter values', () => {
        const ERR_INVALID_INPUT = 'Please provide a non-empty string'
        const badValues = ['', {}, null ]
        
          badValues.map((value) => {
            expect(() =>  {T.createHash(value)}).to.throw(ERR_INVALID_INPUT)
          })
      })

      it('should return a string', () => {
        const expected = 'string'
        const actual = typeof T.createHash('query')

        expect(actual).to.equal(expected)
      })

      it('should return a value different from the input value', () => {
        const actual = T.createHash('query')
        expect(actual).to.not.equal('query')
      })

      it('should return a value with at least a length of one', () => {
        const actual = T.createHash('query').length
        expect(actual).to.be.at.least(1)
      })

      it('should return a value after a minimum delay', () => {
        const start = Date.now()
        T.createHash('query')
        const delta = Date.now() - start
        expect(delta).to.be.at.least(150)
      })

      it('should return a value before a maximum limit', () => {
        const start = Date.now()
        T.createHash('query')
        const delta = Date.now() - start
        expect(delta).to.be.at.most(MAX_TIME_LIMIT)
      })
    })

    describe('the "compareHash" property', () => {
      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof T.compareHash
    
        expect(actual).to.equal(expected)
      })
      
      it('should throw an error if no values are passed', () => {
        const ERR_INVALID_INPUT = 'Please provide a plain text string and a hashed value to compare it to'
      
        expect(() => {
          T.compareHash()
        }).to.throw(ERR_INVALID_INPUT)
      })

      it('should throw an error if the first param is not a string', () => {
        const ERR_INVALID_INPUT = 'Please provide a non-empty string'
        const badValues = ['', {}, null ]
        
          badValues.map((value) => {
            expect(() =>  {T.createHash(value)}).to.throw(ERR_INVALID_INPUT)
          })
      })

      it('', () => {})

      it('should return a boolean', () => {})

      it('', () => {})
    })
  })  
})
