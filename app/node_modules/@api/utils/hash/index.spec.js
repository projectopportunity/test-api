/* eslint-env mocha */

const T = require('./index.js')

/**
 * The maximum amount of time that the hashing should take in milliseconds
 * @type {Number}
 */
const MAX_TIME_LIMIT = 500

describe.only('the "hash" module', () => {
  it('should export an object', () => {
    const expected = 'object'
    const actual = typeof T

    expect(actual).to.equal(expected)
  })

  describe('the exported object', () => {

    it('should have a property called "createHash"', () => {
      const instance = T
      expect(instance).to.have.property('createHash')
    })

    it('should have a property called "compareToHash"', () => {
      const instance = T
      expect(instance).to.have.property('compareToHash')
    })

    describe('the "createHash" property', () => {
      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof T.createHash
    
        expect(actual).to.equal(expected)
      })

      it('should throw an error for invalid parameter values', () => {
        const ERR_INVALID_INPUT = 'Please provide a non-empty string'
        const badValues = ['', {}, null ]
        
          badValues.map((value) => {
            expect(() =>  {T.createHash(value)}).to.throw(ERR_INVALID_INPUT)
          })
      })

      it('should return a string', () => {
        const expected = 'string'
        const actual = typeof T.createHash('query')

        expect(actual).to.equal(expected)
      })

      it('should return a value different from the input value', () => {
        const actual = T.createHash('query')
        expect(actual).to.not.equal('query')
      })

      it('should return a value with at least a length of one', () => {
        const actual = T.createHash('query').length
        expect(actual).to.be.at.least(1)
      })

      it('should return a value after a minimum delay', () => {
        const start = Date.now()
        T.createHash('query')
        const delta = Date.now() - start
        expect(delta).to.be.at.least(100)
      })

      it('should return a value before a maximum limit', () => {
        const start = Date.now()
        T.createHash('query')
        const delta = Date.now() - start
        expect(delta).to.be.at.most(MAX_TIME_LIMIT)
      })
    })

    describe('the "compareToHash" property', () => {
      const ERR_INVALID_INPUT = 'Please provide a plain text string and a hashed value to compare it to'

      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof T.compareToHash
    
        expect(actual).to.equal(expected)
      })
      
      it('should throw an error if no values are passed', () => {
        expect(() => {
          T.compareToHash()
        }).to.throw(ERR_INVALID_INPUT)
      })

      it('should throw an error if the first param is not a string', () => {
        const badValues = ['', {}, null ]
        
        badValues.map((value) => {
          expect(() =>  {
            T.compareToHash(value)
          }).to.throw(ERR_INVALID_INPUT)
        })
      })

      it('should throw an error if the second parameter is missing', () => {
        expect(() => {
          T.compareToHash('test')
        }).to.throw(ERR_INVALID_INPUT)
      })

      it('should throw an error if the second parameter is not a string', () => {
        const badValues = ['', {}, null ]
        
        badValues.map((value) => {
          expect(() =>  {
            T.compareToHash('test', value)
          }).to.throw(ERR_INVALID_INPUT)
        })
      })

      context('when the plain text value is the same as was used to create the hash originally', () => {
        const plainTextValue = 'test'
        let hash

        before(() => {
         hash = T.createHash(plainTextValue)
        })

        it('should return true', () => {
          const expected = true
          const actual = T.compareToHash(plainTextValue, hash)
          expect(actual).to.equal(expected)
        })
      })
    })
  })  
})
